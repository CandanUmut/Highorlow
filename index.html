<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>HighLow 21 ¬∑ Online Kart Tahmin Oyunu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --card: #0b1120;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.2);
      --danger: #f97373;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #0b1120, #020617 55%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      overflow-y: auto;
    }

    .app {
      max-width: 960px;
      width: 100%;
      padding: 24px 16px 32px;
    }

    .card-shell {
      position: relative;
      background: radial-gradient(circle at top, #020617, #020617 40%), var(--card);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.4);
      backdrop-filter: blur(24px);
      overflow: hidden;
    }

    .card-shell > * { position: relative; z-index: 1; }

    .card-shell::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: var(--radius);
      background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 35%),
                  radial-gradient(circle at 80% 0%, rgba(239, 68, 68, 0.08), transparent 30%);
      pointer-events: none;
      opacity: 0.6;
      animation: panelGlow 12s ease-in-out infinite;
      z-index: 0;
    }

    h1 {
      margin-top: 0;
      font-size: 2rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.icon { font-size: 2.2rem; }

    .subtitle {
      color: var(--text-soft);
      margin-bottom: 12px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 16px;
    }

    .game-meta-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 820px) {
      .game-meta-grid {
        grid-template-columns: 1.2fr 1fr;
        align-items: stretch;
      }
    }

    .col {
      flex: 1 1 260px;
    }

    label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    input, select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
    }

    input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(to right, #22c55e, #38bdf8);
      color: #0f172a;
      box-shadow: 0 8px 25px rgba(56, 189, 248, 0.45);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    button.secondary {
      background: transparent;
      border: 1px solid #4b5563;
      color: var(--text-soft);
      box-shadow: none;
    }

    button[disabled] {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    }

    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      margin-bottom: 8px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(75, 85, 99, 0.7);
      color: var(--text-soft);
    }

    .pill-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.7);
    }

    .players {
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.95);
      padding: 10px 12px;
      max-height: 280px;
      overflow-y: auto;
      font-size: 0.9rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
    }

    .players-block { margin-top: 10px; }

    .player-row {
      display: grid;
      grid-template-columns: 1.4fr 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px 6px;
      border-bottom: 1px dashed rgba(31, 41, 55, 0.7);
      border-radius: 10px;
    }

    .player-row.you {
      background: rgba(56, 189, 248, 0.08);
      border: 1px solid rgba(56, 189, 248, 0.25);
      box-shadow: 0 6px 20px rgba(56, 189, 248, 0.08);
    }

    .player-row:last-child { border-bottom: none; }

    .player-name {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }

    .player-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
    }

    .player-tag {
      font-size: 0.75rem;
      padding: 3px 7px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      color: #e5e7eb;
      margin-left: 4px;
      background: rgba(255,255,255,0.03);
      font-weight: 600;
    }

    .player-flags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-start;
    }

    .player-score {
      font-weight: 700;
      color: #e5edff;
      text-align: right;
    }

    .status-banner {
      margin-top: 16px;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 0.9rem;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: radial-gradient(circle at left, rgba(56, 189, 248, 0.12), transparent),
                  rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.8);
    }

    .status-text {
      flex: 1;
      min-width: 200px;
      line-height: 1.4;
    }

    .status-actions-wrap {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      flex: 1;
      flex-wrap: wrap;
      min-width: 240px;
    }

    .status-danger {
      color: var(--danger);
      font-weight: 600;
    }

    #status-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-end;
      align-items: center;
    }

    /* CARD PANEL */
    .card-panel {
      margin-top: 18px;
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), #020617);
      display: flex;
      flex-direction: column;
      gap: 14px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(2, 6, 23, 0.8);
    }

    .card-panel::before {
      content: "";
      position: absolute;
      inset: -20%;
      background: radial-gradient(circle at 30% 30%, rgba(56,189,248,0.12), transparent 35%),
                  radial-gradient(circle at 70% 70%, rgba(248, 113, 113, 0.16), transparent 40%);
      filter: blur(30px);
      animation: panelShimmer 14s linear infinite;
      pointer-events: none;
    }

    .card-area {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: center;
    }

    .card-display {
      width: 160px;
      height: 220px;
      border-radius: 20px;
      background: linear-gradient(145deg, #1f2937, #020617);
      border: 2px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 16px 40px rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 12px;
      position: relative;
      overflow: hidden;
    }

    .intermission-overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 40%, rgba(15, 23, 42, 0.9), rgba(2, 6, 23, 0.95));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      color: var(--text);
      text-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      transition: opacity 0.2s ease;
    }

    .intermission-overlay.hidden { opacity: 0; pointer-events: none; }

    .intermission-count {
      font-size: 3rem;
      font-weight: 800;
      letter-spacing: 0.08em;
    }

    .intermission-label {
      font-size: 0.85rem;
      color: var(--text-soft);
    }

    .card-display-inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 0%, rgba(248, 250, 252, 0.1), transparent 55%);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .card-value {
      font-size: 4rem;
      font-weight: 800;
      text-align: center;
      margin-top: 24px;
      text-shadow: 0 0 16px rgba(0,0,0,0.8);
    }

    .card-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      text-align: center;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .card-range {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: var(--text-soft);
    }

    .timer-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 0.8rem;
    }

    .timer-value {
      font-weight: 700;
      min-width: 24px;
      text-align: right;
    }

    .timer-critical { color: var(--danger); }

    .guess-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 190px;
    }

    .guess-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .guess-btn {
      flex: 1;
      justify-content: center;
    }

    .guess-btn.higher {
      background: linear-gradient(to right, #22c55e, #4ade80);
    }

    .guess-btn.lower {
      background: linear-gradient(to right, #fb923c, #f97316);
    }

    .guess-btn.same {
      background: linear-gradient(145deg, rgba(129, 140, 248, 0.18), rgba(56, 189, 248, 0.14));
      border: 1px solid rgba(129, 140, 248, 0.35);
      width: 100%;
      justify-content: center;
    }

    .guess-btn.selected {
      box-shadow: 0 0 18px rgba(56, 189, 248, 0.7);
      transform: translateY(-1px);
    }

    .guess-btn-pressed {
      transform: translateY(-2px) scale(0.995) !important;
      box-shadow: 0 10px 22px rgba(56, 189, 248, 0.4) !important;
    }

    .guess-info {
      font-size: 0.8rem;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(56, 189, 248, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
    }

    .guess-feedback {
      margin-top: 6px;
      font-weight: 600;
    }

    .guess-feedback.error { color: var(--danger); }

    .current-guess-row {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 700;
      color: #e5edff;
    }

    .current-guess-label { color: var(--text-soft); font-weight: 600; }

    .log {
      margin-top: 12px;
      font-size: 0.8rem;
      color: var(--text-soft);
      max-height: 120px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .log-line { margin-bottom: 4px; }

    .scoreboard {
      margin-top: 12px;
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      padding: 10px 12px;
      font-size: 0.8rem;
    }

    .tagline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(56, 189, 248, 0.3);
      color: var(--text);
      background: rgba(56, 189, 248, 0.08);
      margin-left: 8px;
      white-space: nowrap;
    }

    .tagline.shield {
      border-color: rgba(129, 140, 248, 0.6);
      background: rgba(129, 140, 248, 0.16);
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(31,41,55,0.7);
    }

    .score-row.you {
      background: rgba(56, 189, 248, 0.08);
      border-radius: 8px;
      padding: 6px 8px;
      border: 1px solid rgba(56, 189, 248, 0.2);
    }

    .score-row:last-child { border-bottom: none; }

    .score-points {
      font-weight: 700;
      color: #e5edff;
    }

    .error {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 6px;
    }

    .info-panel {
      margin-top: 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(75, 85, 99, 0.6);
      border-radius: 12px;
      padding: 14px 16px;
      color: var(--text-soft);
      font-size: 0.9rem;
      line-height: 1.5;
      display: none;
    }

    .info-panel.visible {
      display: block;
    }

    .info-panel h3 {
      margin: 0 0 8px 0;
      color: var(--text);
      font-size: 1rem;
    }

    .info-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    @media (min-width: 900px) {
      .info-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    .lang-switch {
      position: absolute;
      right: 12px;
      top: 12px;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .lang-btn {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.8);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      cursor: pointer;
    }

    .lang-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.4);
    }

    .help-icon-btn {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: 1px solid rgba(56, 189, 248, 0.4);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.5);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    .help-icon-btn:hover { box-shadow: 0 10px 30px rgba(56, 189, 248, 0.2); }

    @keyframes panelGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.9; }
    }

    @keyframes panelShimmer {
      0% { transform: rotate(0deg) scale(1); opacity: 0.7; }
      50% { transform: rotate(180deg) scale(1.05); opacity: 1; }
      100% { transform: rotate(360deg) scale(1); opacity: 0.7; }
    }

    @keyframes cardFlash {
      0% { transform: scale(1); box-shadow: 0 16px 40px rgba(0,0,0,0.9); }
      50% { transform: scale(1.04); box-shadow: 0 18px 48px rgba(56, 189, 248, 0.35); }
      100% { transform: scale(1); box-shadow: 0 16px 40px rgba(0,0,0,0.9); }
    }

    .card-display.card-flash {
      animation: cardFlash 0.35s ease;
    }

    @media (max-width: 768px) {
      .card-shell { padding: 16px; }
      .card-display { width: 140px; height: 190px; }
      .card-value { font-size: 3.2rem; }
    }

    @media (max-width: 600px) {
      .card-area {
        justify-content: center;
        align-items: stretch;
      }

      .guess-row.two-col {
        flex-wrap: nowrap;
      }

      .guess-row.single .guess-btn {
        width: 100%;
      }

      .guess-btn {
        font-size: 0.95rem;
        padding: 10px 14px;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="card-shell">
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="tr">üáπüá∑ TR</button>
      <button class="lang-btn" data-lang="en">üá¨üáß EN</button>
      <button id="help-toggle-btn" class="help-icon-btn" aria-label="Help">‚ùì</button>
    </div>

    <h1>
      <span class="icon">üÉè</span>
      <span id="title-text">HighLow 21</span>
    </h1>
    <div class="subtitle" id="subtitle-text">
      1‚Äì21 arasƒ± kartlar. Sƒ±radaki kart daha mƒ± y√ºksek, daha mƒ± al√ßak? Zaman dolmadan tahmin et, puanlarƒ± topla!
    </div>

    <!-- SETUP -->
    <div class="row" id="setup-section">
      <div class="col">
        <div class="section-title" id="create-section-title">Yeni Oyun Olu≈ütur</div>
        <label id="label-creator-name">ƒ∞smin</label>
        <input id="creator-name" placeholder="Umut, Nova vs." />

        <label style="margin-top:8px;" id="label-time-limit">Tur S√ºresi (saniye)</label>
        <select id="time-limit">
          <option value="10" selected>10</option>
          <option value="15">15</option>
          <option value="20">20</option>
        </select>

        <label style="margin-top:8px;" id="label-target-score">Hedef Puan</label>
        <select id="target-score">
          <option value="10">10</option>
          <option value="15" selected>15</option>
          <option value="20">20</option>
        </select>

        <button id="create-game-btn" style="margin-top:12px;">
          <span id="btn-create-text">Oyun Olu≈ütur</span> <span>‚ûï</span>
        </button>
        <div id="create-error" class="error"></div>
      </div>

      <div class="col">
        <div class="section-title" id="join-section-title">Koda / Linke G√∂re Katƒ±l</div>
        <label id="label-join-name">ƒ∞smin</label>
        <input id="join-name" placeholder="ƒ∞smin" />

        <label style="margin-top:8px;" id="label-join-code">Oda Kodu</label>
        <input id="join-code" placeholder="√ñrn: ABCD12" />

        <button id="join-game-btn" style="margin-top:12px;" class="secondary">
          <span id="btn-join-text">Oyuna Katƒ±l</span> <span>‚û°Ô∏è</span>
        </button>
        <div id="join-help-text" style="margin-top:8px;font-size:0.8rem;color:var(--text-soft);">
          Eƒüer linkle geldiysen kod otomatik dolabilir.
        </div>
        <div id="join-error" class="error"></div>
      </div>
    </div>

    <!-- GAME -->
    <div id="game-section" style="display:none; margin-top:16px;">
      <div class="game-meta-grid">
        <div class="col">
          <div class="section-title" id="room-section-title">Oda</div>
          <div class="pill">
            <span class="pill-dot"></span>
            <span id="room-status-text">Bekleniyor...</span>
          </div>
          <div style="margin-top:8px;font-size:0.85rem;">
            <span id="room-code-label">Oda kodu:</span>
            <strong id="room-code">-</strong>
          </div>
          <div style="margin-top:4px;font-size:0.8rem;">
            <span id="room-link-label">Link:</span>
            <a id="room-link" class="link" href="#" style="color:var(--accent);word-break:break-all;"></a>
          </div>
          <div style="margin-top:4px;font-size:0.8rem;">
            <span id="room-target-label">Hedef:</span>
            <strong id="room-target">-</strong>
          </div>
        </div>

        <div class="status-banner">
          <div id="status-text" class="status-text">Oyun hen√ºz ba≈ülamadƒ±.</div>
          <div class="status-actions-wrap">
            <div id="status-actions"></div>
          </div>
        </div>
      </div>

      <div class="players-block">
        <div class="section-title" id="players-section-title">Oyuncular</div>
        <div class="players" id="players-list"></div>
      </div>

      <div class="card-panel">
        <div class="section-title" id="card-section-title">Kart & Tahmin</div>
        <div class="card-area">
          <div>
            <div class="card-display" id="card-display">
              <div class="card-display-inner"></div>
              <div class="intermission-overlay hidden" id="intermission-overlay">
                <div class="intermission-count" id="intermission-count">3</div>
                <div class="intermission-label" id="intermission-label">Yeni kart geliyor</div>
              </div>
              <div class="card-range">
                <span>1</span>
                <span>21</span>
              </div>
              <div class="card-value" id="card-value">?</div>
              <div class="card-label" id="card-label">≈ûimdiki Kart</div>
            </div>
          </div>
          <div class="guess-buttons">
            <div class="guess-row two-col">
              <button class="guess-btn higher" id="btn-guess-higher">
                üî∫ <span id="btn-higher-text">Daha Y√ºksek</span>
              </button>
              <button class="guess-btn lower" id="btn-guess-lower">
                üîª <span id="btn-lower-text">Daha Al√ßak</span>
              </button>
            </div>
            <div class="guess-row single">
              <button class="guess-btn same" id="btn-guess-same">
                ‚≠ï <span id="btn-same-text">Aynƒ± kart gelir</span>
              </button>
            </div>
            <div class="guess-row" style="align-items:center;">
              <div class="timer-chip">
                ‚è± <span id="timer-label">Kalan s√ºre</span>:
                <span class="timer-value" id="timer-value">--</span>
              </div>
            </div>
            <div class="guess-info" id="guess-info">
              <div id="guess-info-text">Her tur: Tahmin etmeyen -1 puan, doƒüru tahmin +2 puan, yanlƒ±≈ü tahmin 0 puan.</div>
              <div class="guess-feedback" id="guess-feedback"></div>
              <div class="current-guess-row">
                <span class="current-guess-label" id="current-guess-label">G√ºncel tahminin:</span>
                <span id="current-guess-value">Yok</span>
              </div>
            </div>
          </div>
        </div>

        <div class="log" id="log"></div>
      </div>

      <div class="scoreboard" id="scoreboard">
        <div class="section-title" id="scoreboard-title">Skor Tablosu</div>
        <div id="scoreboard-body"></div>
      </div>

      <div class="info-panel" id="how-to-play">
        <div class="info-grid">
          <div>
            <h3>Nasƒ±l Oynanƒ±r?</h3>
            <ul style="margin:0 0 6px 16px; padding:0; color:var(--text-soft);">
              <li>1-21 numaralƒ± kartlarla oynanƒ±r. √ñnce mevcut kart a√ßƒ±lƒ±r.</li>
              <li>S√ºre i√ßinde bir sonraki kartƒ±n daha <strong>y√ºksek</strong>, <strong>d√º≈ü√ºk</strong> ya da <strong>aynƒ±</strong> (aynƒ± kart gelir) olacaƒüƒ±nƒ± tahmin et.</li>
              <li>Kartƒ±n deƒüerine g√∂re y√ºksek/d√º≈ü√ºk tahmini g√ºvenli veya riskli sayƒ±lƒ±r; riskli doƒüru tahmin y√ºksek puan getirir, yanlƒ±≈ü tahmin ceza yazabilir.</li>
              <li>"Aynƒ± kart gelir" tahmini √ßok risklidir: tutarsa b√ºy√ºk √∂d√ºl, tutmazsa ekstra ceza.</li>
              <li>Tahmin etmeyen oyuncular k√º√ß√ºk bir ceza alƒ±r.</li>
              <li>Art arda doƒüru bildik√ße combo √ßarpanƒ± artar; seri 3 olunca kalkan kazanƒ±rsƒ±n, ilk hatanda cezayƒ± emer.</li>
              <li>Oda kurulurken belirlenen hedef puana ilk ula≈üan kazanƒ±r.</li>
            </ul>
            <p style="margin:8px 0 0 0; color:var(--text-soft); font-size:0.85rem;">Bu oyun √ºcretsiz bir zihin egzersizidir; ger√ßek para, √∂d√ºl veya bahis i√ßermez. Kumar oynamak dinen sakƒ±ncalƒ± ve yasaktƒ±r.</p>
          </div>
          <div>
            <h3>How to Play (Short English)</h3>
            <p style="margin:0;">Cards are numbered 1-21. Each round you guess if the next card is higher, lower, or exactly the same card. Safer vs risky guesses change the points. Correct "same" is rare but gives a big bonus; wrong guesses penalize you. Consecutive correct answers build a combo multiplier and can grant a one-time shield. No gambling or real prizes here‚Äîjust a free brain-training game.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  // Supabase bilgilerin (Math Bomb ile aynƒ± projeyi kullanabilirsin)
  const SUPABASE_URL = "https://tkggowekxmnlixwinszl.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrZ2dvd2VreG1ubGl4d2luc3psIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3MzI1NjcsImV4cCI6MjA4MDMwODU2N30.y1GSvarl9YyBqMaP8x6SXeD88EJ10gjee4rlr6oLyZg";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const LS_KEY = "hl21_state_v1";
  const LS_LANG = "hl21_lang";
  const GRACE_MS = 1000;
  const INTERMISSION_MS = 3000;
  const VERY_LOW_SCORE = -20;

  // --- i18n ---
  let currentLang = localStorage.getItem(LS_LANG) || "tr";

  const textMap = {
    tr: {
      title: "HighLow 21",
      subtitle: "1‚Äì21 arasƒ± kartlar. Sƒ±radaki kart daha mƒ± y√ºksek, daha mƒ± al√ßak yoksa aynƒ± mƒ±? Zaman dolmadan tahmin et, puanlarƒ± topla!",
      createSectionTitle: "Yeni Oyun Olu≈ütur",
      joinSectionTitle: "Koda / Linke G√∂re Katƒ±l",
      labelCreatorName: "ƒ∞smin",
      labelTimeLimit: "Tur S√ºresi (saniye)",
      labelTargetScore: "Hedef Puan",
      labelJoinName: "ƒ∞smin",
      labelJoinCode: "Oda Kodu",
      btnCreate: "Oyun Olu≈ütur",
      btnJoin: "Oyuna Katƒ±l",
      joinHelp: "Eƒüer linkle geldiysen kod otomatik dolabilir.",
      roomSectionTitle: "Oda",
      roomCodeLabel: "Oda kodu:",
      roomLinkLabel: "Link:",
      roomTargetLabel: "Hedef:",
      playersSectionTitle: "Oyuncular",
      cardSectionTitle: "Kart & Tahmin",
      statusWaiting: "Oyun hen√ºz ba≈ülamadƒ±. Oyuncular katƒ±labilir.",
      statusRunning: "Tahmin zamanƒ±! Sƒ±radaki kart daha y√ºksek mi, daha al√ßak mƒ± yoksa aynƒ± mƒ±?",
      statusFinished: "Oyun bitti.",
      labelScoreboard: "Skor Tablosu",
      btnStartGame: "Oyunu Ba≈ülat",
      btnPlayAgain: "Skorlarƒ± Sƒ±fƒ±rla ve Devam",
      btnEndGame: "Oyunu Bitir",
      btnNewRoom: "Yeni Oda",
      btnExitRoom: "Odadan √áƒ±k",
      btnHigher: "Daha Y√ºksek",
      btnLower: "Daha Al√ßak",
      btnSame: "Aynƒ± kart gelir",
      helpButtonLabel: "Yardƒ±m / Nasƒ±l Oynanƒ±r",
      errorNameRequired: "ƒ∞smini yazmalƒ±sƒ±n.",
      errorCodeRequired: "Oda kodu bo≈ü olamaz.",
      errorRoomNotFound: "B√∂yle bir oda bulunamadƒ±.",
      timerLabel: "Kalan s√ºre",
      guessInfo:
        "Puan: Tahmin yok -1. G√ºvenli doƒüru +1 / riskli doƒüru +3. Yanlƒ±≈ü: g√ºvenli 0, riskli -1. 'Aynƒ± kart gelir' doƒüru +5, yanlƒ±≈ü -2. Combo √ßarpanƒ± streak'e g√∂re artar, kalkan bir kez cezayƒ± siler.",
      currentGuessLabel: "G√ºncel tahminin:",
      guessValueNone: "Yok",
      guessValueHigher: "Daha y√ºksek",
      guessValueLower: "Daha al√ßak",
      guessValueSame: "Aynƒ±",
      guessTooEarly: "Ara veriliyor, geri sayƒ±m bitince tahmin yapabilirsin.",
      guessTooLate: "S√ºre bitti, tahmin alƒ±namƒ±yor.",
      guessSaved: "Tahmin kaydedildi!",
      youLabel: "Sen",
      hostTag: "Kurucu",
      winnerPrefix: "Kazanan:",
      intermissionLabel: "Yeni kart 3-2-1",
      logGameCreated: slug => `Oyun olu≈üturuldu. Kod: ${slug}`,
      logJoined: slug => `Odaya katƒ±ldƒ±n. Kod: ${slug}`,
      logStart: (card, limit) => `Oyun ba≈üladƒ±. ƒ∞lk kart: ${card}. Tur s√ºresi: ${limit} sn.`,
      logRoundResult: (current, next) => `Tur bitti. Kart ${current} ‚Üí ${next}.`,
      logWin: name => `üéâ ${name} hedef puana ula≈ütƒ±! Oyun bitti.`,
      logScoreDelta: (name, delta) => {
        if (delta > 0) return `${name}: +${delta} puan`;
        if (delta < 0) return `${name}: ${delta} puan`;
        return `${name}: 0 puan`;
      },
      logNoGuess: name => `${name} tahmin yapmadƒ±.`,
      logEndedByHost: "Oyun kurucu tarafƒ±ndan bitirildi.",
      logAutoLow: "T√ºm oyuncular -20'nin altƒ±nda. Oyun otomatik sona erdi.",
    },
    en: {
      title: "HighLow 21",
      subtitle: "Cards from 1 to 21. Will the next card be higher, lower, or the same? Guess before time runs out and score points!",
      createSectionTitle: "Create New Game",
      joinSectionTitle: "Join with Code / Link",
      labelCreatorName: "Your name",
      labelTimeLimit: "Round Time (seconds)",
      labelTargetScore: "Target Score",
      labelJoinName: "Your name",
      labelJoinCode: "Room Code",
      btnCreate: "Create Game",
      btnJoin: "Join Game",
      joinHelp: "If you came via link, the code may auto-fill.",
      roomSectionTitle: "Room",
      roomCodeLabel: "Room code:",
      roomLinkLabel: "Link:",
      roomTargetLabel: "Target:",
      playersSectionTitle: "Players",
      cardSectionTitle: "Card & Guess",
      statusWaiting: "Game has not started yet. Players can still join.",
      statusRunning: "Guess time! Will the next card be higher, lower, or the same?",
      statusFinished: "Game over.",
      labelScoreboard: "Scoreboard",
      btnStartGame: "Start Game",
      btnPlayAgain: "Reset Scores & Continue",
      btnEndGame: "End Game",
      btnNewRoom: "New Room",
      btnExitRoom: "Exit Room",
      btnHigher: "Higher",
      btnLower: "Lower",
      btnSame: "Same card",
      helpButtonLabel: "Help / How to Play",
      errorNameRequired: "Please enter your name.",
      errorCodeRequired: "Room code cannot be empty.",
      errorRoomNotFound: "Room not found.",
      timerLabel: "Time left",
      guessInfo:
        "Points: No guess -1. Safe correct +1 / risky correct +3. Wrong: safe 0, risky -1. 'Same card' correct +5, wrong -2. Combo multiplier grows with streak; shield negates one negative round.",
      currentGuessLabel: "Your current guess:",
      guessValueNone: "None",
      guessValueHigher: "Higher",
      guessValueLower: "Lower",
      guessValueSame: "Same",
      guessTooEarly: "Intermission now; guesses open when the timer starts.",
      guessTooLate: "Time is over; guess window closed.",
      guessSaved: "Guess saved!",
      youLabel: "You",
      hostTag: "Host",
      winnerPrefix: "Winner:",
      intermissionLabel: "New card in 3-2-1",
      logGameCreated: slug => `Game created. Code: ${slug}`,
      logJoined: slug => `Joined room. Code: ${slug}`,
      logStart: (card, limit) => `Game started. First card: ${card}. Round time: ${limit}s.`,
      logRoundResult: (current, next) => `Round ended. Card ${current} ‚Üí ${next}.`,
      logWin: name => `üéâ ${name} reached the target score! Game over.`,
      logScoreDelta: (name, delta) => {
        if (delta > 0) return `${name}: +${delta} points`;
        if (delta < 0) return `${name}: ${delta} points`;
        return `${name}: 0 points`;
      },
      logNoGuess: name => `${name} made no guess.`,
      logEndedByHost: "Game ended by host.",
      logAutoLow: "All players reached very low scores. Game finished.",
    }
  };

  function applyLanguage() {
    const t = textMap[currentLang];
    document.getElementById("title-text").textContent = t.title;
    document.getElementById("subtitle-text").textContent = t.subtitle;
    document.getElementById("create-section-title").textContent = t.createSectionTitle;
    document.getElementById("join-section-title").textContent = t.joinSectionTitle;
    document.getElementById("label-creator-name").textContent = t.labelCreatorName;
    document.getElementById("label-time-limit").textContent = t.labelTimeLimit;
    document.getElementById("label-target-score").textContent = t.labelTargetScore;
    document.getElementById("label-join-name").textContent = t.labelJoinName;
    document.getElementById("label-join-code").textContent = t.labelJoinCode;
    document.getElementById("btn-create-text").textContent = t.btnCreate;
    document.getElementById("btn-join-text").textContent = t.btnJoin;
    document.getElementById("join-help-text").textContent = t.joinHelp;
    document.getElementById("room-section-title").textContent = t.roomSectionTitle;
    document.getElementById("room-code-label").textContent = t.roomCodeLabel;
    document.getElementById("room-link-label").textContent = t.roomLinkLabel;
    document.getElementById("room-target-label").textContent = t.roomTargetLabel;
    document.getElementById("players-section-title").textContent = t.playersSectionTitle;
    document.getElementById("card-section-title").textContent = t.cardSectionTitle;
    document.getElementById("scoreboard-title").textContent = t.labelScoreboard;
    document.getElementById("btn-higher-text").textContent = t.btnHigher;
    document.getElementById("btn-lower-text").textContent = t.btnLower;
    document.getElementById("btn-same-text").textContent = t.btnSame;
    document.getElementById("timer-label").textContent = t.timerLabel;
    if (guessInfoTextEl) guessInfoTextEl.textContent = t.guessInfo;
    if (currentGuessLabelEl) currentGuessLabelEl.textContent = t.currentGuessLabel;
    if (helpToggleBtn) {
      helpToggleBtn.setAttribute("aria-label", t.helpButtonLabel);
      helpToggleBtn.title = t.helpButtonLabel;
    }
    intermissionLabelEl.textContent = t.intermissionLabel;
    updateCurrentGuessDisplay();
    updateRoomUI();
  }

  // --- Audio ---
  let audioCtx = null;
  function getAudioCtx() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    return audioCtx;
  }

  function playTickSound(remaining) {
    const ctx = getAudioCtx();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const baseFreq = remaining <= 3 ? 900 : 550;
    osc.type = "square";
    osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
    gain.gain.setValueAtTime(remaining <= 3 ? 0.18 : 0.07, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.09);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.09);
  }

  function playRevealSound() {
    const ctx = getAudioCtx();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(420, ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(260, ctx.currentTime + 0.35);
    gain.gain.setValueAtTime(0.18, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.4);
  }

  function playScoreDeltaSound(delta) {
    const ctx = getAudioCtx();
    if (!ctx || delta === 0) return;

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    if (delta > 0) {
      osc.type = "triangle";
      osc.frequency.setValueAtTime(660, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(880, ctx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.18, ctx.currentTime);
    } else {
      osc.type = "square";
      osc.frequency.setValueAtTime(220, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(160, ctx.currentTime + 0.12);
      gain.gain.setValueAtTime(0.16, ctx.currentTime);
    }

    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.25);
  }

  function playClickSound() {
    const ctx = getAudioCtx();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(520, ctx.currentTime);
    gain.gain.setValueAtTime(0.12, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.12);
  }

  // --- Helpers ---
  function randomSlug(len = 6) {
    return Math.random().toString(36).substring(2, 2 + len).toUpperCase();
  }

  function log(msg) {
    const logEl = document.getElementById("log");
    const line = document.createElement("div");
    line.className = "log-line";
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function randCard() {
    return 1 + Math.floor(Math.random() * 21); // 1..21
  }

  function isSafeGuess(current, guess) {
    if (guess === "higher") return current >= 1 && current <= 4;
    if (guess === "lower") return current >= 18 && current <= 21;
    return false;
  }

  function getComboMultiplier(streak) {
    if (streak >= 4) return 2;
    if (streak >= 2) return 1.5;
    return 1;
  }

  function cardColor(num) {
    // 1 -> mavi/ye≈üil, 21 -> kƒ±rmƒ±zƒ±
    const t = (num - 1) / 20; // 0..1
    const hue = 190 - t * 190; // 190 (cyan) -> 0 (red)
    return `linear-gradient(145deg, hsl(${hue},75%,52%), hsl(${Math.max(
      hue - 30,
      0
    )},85%,45%))`;
  }

  function getRoundTiming() {
    if (!currentGame || !currentGame.deadline_at || !currentGame.time_limit_seconds) {
      return null;
    }
    const deadlineMs = new Date(currentGame.deadline_at).getTime();
    const guessStartMs = deadlineMs - currentGame.time_limit_seconds * 1000;
    return { deadlineMs, guessStartMs };
  }

  function translateGuessValue(val) {
    const t = textMap[currentLang];
    if (val === "higher") return t.guessValueHigher;
    if (val === "lower") return t.guessValueLower;
    if (val === "same") return t.guessValueSame;
    return t.guessValueNone;
  }

  function setGuessFeedback(message = "", isError = false) {
    if (!guessFeedbackEl) return;
    guessFeedbackEl.textContent = message || "";
    guessFeedbackEl.classList.toggle("error", !!isError && !!message);
  }

  function updateCurrentGuessDisplay() {
    const t = textMap[currentLang];
    if (currentGuessLabelEl) currentGuessLabelEl.textContent = t.currentGuessLabel;
    if (!currentGuessValueEl) return;
    const me = players.find(p => p.id === (currentPlayer && currentPlayer.id));
    currentGuessValueEl.textContent = translateGuessValue(me && me.last_guess);
  }

  function saveLocalState() {
    if (!currentGame || !currentPlayer) return;
    try {
      localStorage.setItem(
        LS_KEY,
        JSON.stringify({ gameSlug: currentGame.slug, playerId: currentPlayer.id })
      );
    } catch (_) {}
  }

  function clearLocalState() {
    try { localStorage.removeItem(LS_KEY); } catch (_) {}
  }

  function resetLocalScoreSoundState() {
    lastKnownScore = null;
    lastKnownRoundNumber = null;
  }

  function updateLocalScoreSoundState() {
    if (!currentPlayer || !currentGame) return;
    const me = players.find(p => p.id === currentPlayer.id);
    if (!me) return;

    const thisScore = me.score || 0;
    const thisRound = currentGame.round_number || 0;

    if (lastKnownRoundNumber !== null && thisRound === lastKnownRoundNumber && lastKnownScore !== null) {
      return;
    }

    if (lastKnownRoundNumber !== null && thisRound > lastKnownRoundNumber && lastKnownScore !== null) {
      const delta = thisScore - lastKnownScore;
      if (delta !== 0) {
        playScoreDeltaSound(delta);
      }
    }

    lastKnownScore = thisScore;
    lastKnownRoundNumber = thisRound;
  }

  // --- State ---
  let currentGame = null;
  let currentPlayer = null;
  let players = [];
  let lastRevealedScores = [];
  let isCreator = false;
  let pollInterval = null;
  let timerInterval = null;
  let lastSecondShown = null;
  let resolvingRound = false;
  let lastKnownScore = null;
  let lastKnownRoundNumber = null;
  let lastCardValue = null;

  // DOM refs
  const setupSection = document.getElementById("setup-section");
  const gameSection = document.getElementById("game-section");
  const roomCodeEl = document.getElementById("room-code");
  const roomLinkEl = document.getElementById("room-link");
  const roomStatusText = document.getElementById("room-status-text");
  const roomTargetEl = document.getElementById("room-target");
  const playersList = document.getElementById("players-list");
  const statusText = document.getElementById("status-text");
  const statusActions = document.getElementById("status-actions");
  const cardDisplayEl = document.getElementById("card-display");
  const cardValueEl = document.getElementById("card-value");
  const intermissionOverlay = document.getElementById("intermission-overlay");
  const intermissionCountEl = document.getElementById("intermission-count");
  const intermissionLabelEl = document.getElementById("intermission-label");
  const timerValueEl = document.getElementById("timer-value");
  const scoreboardBodyEl = document.getElementById("scoreboard-body");
  const guessBtnHigher = document.getElementById("btn-guess-higher");
  const guessBtnLower = document.getElementById("btn-guess-lower");
  const guessBtnSame = document.getElementById("btn-guess-same");
  const helpPanel = document.getElementById("how-to-play");
  const helpToggleBtn = document.getElementById("help-toggle-btn");
  const guessInfoTextEl = document.getElementById("guess-info-text");
  const guessFeedbackEl = document.getElementById("guess-feedback");
  const currentGuessLabelEl = document.getElementById("current-guess-label");
  const currentGuessValueEl = document.getElementById("current-guess-value");

  let uiUpdatePending = false;
  function scheduleUIUpdate() {
    if (uiUpdatePending) return;
    uiUpdatePending = true;
    requestAnimationFrame(() => {
      uiUpdatePending = false;
      updateRoomUI();
      updateLocalScoreSoundState();
    });
  }

  if (helpToggleBtn && helpPanel) {
    helpToggleBtn.addEventListener("click", () => {
      const isVisible = helpPanel.classList.toggle("visible");
      helpToggleBtn.classList.toggle("active", isVisible);
    });
  }

  function updateRoomUI() {
    const t = textMap[currentLang];
    if (!currentGame) return;

    const timings = getRoundTiming();
    const now = Date.now();
    const inIntermission =
      currentGame.status === "running" && timings && now < timings.guessStartMs;

    roomCodeEl.textContent = currentGame.slug;
    const link = `${window.location.origin}${window.location.pathname}?game=${currentGame.slug}`;
    roomLinkEl.href = link;
    roomLinkEl.textContent = link;
    roomTargetEl.textContent = currentGame.target_score ?? "-";

    // status text
    let label = "";
    if (currentGame.status === "waiting") label = t.statusWaiting;
    else if (currentGame.status === "running") label = inIntermission ? t.intermissionLabel : t.statusRunning;
    else label = t.statusFinished;
    roomStatusText.textContent = label;
    statusText.textContent = label;

    // current card visuals
    const showHiddenCard = inIntermission || !currentGame.current_card;
    if (!showHiddenCard && currentGame.current_card) {
      const v = currentGame.current_card;
      cardValueEl.textContent = v.toString();
      cardDisplayEl.style.background = cardColor(v);
      if (lastCardValue !== v) {
        cardDisplayEl.classList.remove("card-flash");
        void cardDisplayEl.offsetWidth;
        cardDisplayEl.classList.add("card-flash");
        setTimeout(() => cardDisplayEl.classList.remove("card-flash"), 400);
      }
      lastCardValue = v;
    } else {
      cardValueEl.textContent = "?";
      cardDisplayEl.style.background = "linear-gradient(145deg, #1f2937, #020617)";
      lastCardValue = null;
    }

    // players list
    playersList.innerHTML = "";
    players.forEach(p => {
      const row = document.createElement("div");
      row.className = "player-row";
      if (currentPlayer && p.id === currentPlayer.id) row.classList.add("you");

      const left = document.createElement("div");
      left.className = "player-name";

      const dot = document.createElement("div");
      dot.className = "player-dot";
      left.appendChild(dot);

      const nameSpan = document.createElement("span");
      nameSpan.textContent = p.name;
      left.appendChild(nameSpan);

      if (currentPlayer && p.id === currentPlayer.id) {
        const youTag = document.createElement("span");
        youTag.className = "player-tag";
        youTag.style.borderColor = "rgba(56,189,248,0.7)";
        youTag.style.color = "var(--accent)";
        youTag.textContent = t.youLabel;
        left.appendChild(youTag);
      }

      const flags = document.createElement("div");
      flags.className = "player-flags";
      if (p.is_creator) {
        const hostTag = document.createElement("span");
        hostTag.className = "player-tag";
        hostTag.textContent = t.hostTag;
        flags.appendChild(hostTag);
      }
      const streakVal = p.streak || 0;
      const comboMult = getComboMultiplier(streakVal);
      if (streakVal > 1) {
        const comboTag = document.createElement("span");
        comboTag.className = "player-tag";
        comboTag.style.borderColor = "rgba(56,189,248,0.5)";
        comboTag.style.color = "var(--accent)";
        comboTag.textContent = `COMBO x${comboMult}`;
        flags.appendChild(comboTag);
      }
      if (p.has_shield) {
        const shieldTag = document.createElement("span");
        shieldTag.className = "player-tag";
        shieldTag.style.borderColor = "rgba(129,140,248,0.6)";
        shieldTag.style.color = "#c4d4ff";
        shieldTag.textContent = "üõ°";
        flags.appendChild(shieldTag);
      }
      if (p.last_guess === "higher") {
        const g = document.createElement("span");
        g.className = "player-tag";
        g.style.borderColor = "#22c55e";
        g.style.color = "#22c55e";
        g.textContent = "üî∫";
        flags.appendChild(g);
      }
      if (p.last_guess === "lower") {
        const g = document.createElement("span");
        g.className = "player-tag";
        g.style.borderColor = "#fb923c";
        g.style.color = "#fb923c";
        g.textContent = "üîª";
        flags.appendChild(g);
      }
      if (p.last_guess === "same") {
        const g = document.createElement("span");
        g.className = "player-tag";
        g.style.borderColor = "rgba(129,140,248,0.7)";
        g.style.color = "#c7d2fe";
        g.textContent = "‚≠ï";
        flags.appendChild(g);
      }

      const score = document.createElement("div");
      score.className = "player-score";
      const s = p.score || 0;
      score.textContent = s > 0 ? `+${s}` : `${s}`;

      row.appendChild(left);
      row.appendChild(flags);
      row.appendChild(score);
      playersList.appendChild(row);
    });

    // scoreboard (freeze during intermission so points reveal with card)
    if (!inIntermission || lastRevealedScores.length === 0) {
      lastRevealedScores = players.map(p => ({ ...p }));
    }

    scoreboardBodyEl.innerHTML = "";
    const scoreSource = inIntermission ? lastRevealedScores : players;
    const sorted = [...scoreSource].sort((a,b) => (b.score || 0) - (a.score || 0));
    sorted.forEach(p => {
      const row = document.createElement("div");
      row.className = "score-row";
      if (currentPlayer && p.id === currentPlayer.id) row.classList.add("you");
      const name = document.createElement("div");
      name.textContent = p.name;
      if (currentPlayer && p.id === currentPlayer.id) {
        const youTag = document.createElement("span");
        youTag.className = "tagline";
        youTag.textContent = t.youLabel;
        name.appendChild(youTag);
      }
      const streakVal = p.streak || 0;
      const comboMult = getComboMultiplier(streakVal);
      if (streakVal > 1) {
        const tag = document.createElement("span");
        tag.className = "tagline";
        tag.textContent = `COMBO x${comboMult}`;
        name.appendChild(tag);
      }
      if (p.has_shield) {
        const tag = document.createElement("span");
        tag.className = "tagline shield";
        tag.textContent = "üõ°";
        name.appendChild(tag);
      }
      const pts = document.createElement("div");
      pts.className = "score-points";
      const s = p.score || 0;
      pts.textContent = s > 0 ? `+${s}` : `${s}`;
      row.appendChild(name);
      row.appendChild(pts);
      scoreboardBodyEl.appendChild(row);
    });

    // action buttons
    statusActions.innerHTML = "";
    if (isCreator && currentGame.status === "waiting") {
      const startBtn = document.createElement("button");
      startBtn.textContent = t.btnStartGame;
      startBtn.onclick = startGame;
      statusActions.appendChild(startBtn);
    }
    if (isCreator && currentGame.status === "running") {
      const endBtn = document.createElement("button");
      endBtn.className = "secondary";
      endBtn.textContent = t.btnEndGame;
      endBtn.onclick = endGame;
      statusActions.appendChild(endBtn);
    }
    if (isCreator && currentGame.status === "finished") {
      const again = document.createElement("button");
      again.textContent = t.btnPlayAgain;
      again.onclick = resetScoresAndContinue;
      statusActions.appendChild(again);

      const newRoom = document.createElement("button");
      newRoom.className = "secondary";
      newRoom.textContent = t.btnNewRoom;
      newRoom.onclick = () => {
        clearLocalState();
        window.location.href = window.location.pathname;
      };
      statusActions.appendChild(newRoom);
    }

    const exitBtn = document.createElement("button");
    exitBtn.className = "secondary";
    exitBtn.textContent = t.btnExitRoom;
    exitBtn.onclick = exitRoom;
    statusActions.appendChild(exitBtn);

    // guess buttons enable/disable
    const canGuess =
      currentGame.status === "running" &&
      currentGame.deadline_at &&
      currentPlayer &&
      timings &&
      !inIntermission &&
      now < timings.deadlineMs;

    const me = players.find(p => p.id === (currentPlayer && currentPlayer.id));
    const alreadyGuessed = !!(me && me.last_guess);

    const disabled = !canGuess || alreadyGuessed;
    guessBtnHigher.disabled = disabled;
    guessBtnLower.disabled = disabled;
    guessBtnSame.disabled = disabled;

    guessBtnHigher.classList.toggle(
      "selected",
      !!me && me.last_guess === "higher"
    );
    guessBtnLower.classList.toggle(
      "selected",
      !!me && me.last_guess === "lower"
    );
    guessBtnSame.classList.toggle(
      "selected",
      !!me && me.last_guess === "same"
    );

    if (canGuess && !alreadyGuessed) {
      setGuessFeedback("");
    }

    updateCurrentGuessDisplay();
  }

  async function fetchPlayers(gameId) {
    const { data, error } = await supabase
      .from("hl_players")
      .select("*")
      .eq("game_id", gameId)
      .order("created_at", { ascending: true });
    if (!error) {
      players = data;
      if (currentPlayer) {
        const me = players.find(p => p.id === currentPlayer.id);
        if (me) currentPlayer = me;
      }
      scheduleUIUpdate();
    }
  }

  async function fetchGameBySlug(slug) {
    const { data, error } = await supabase
      .from("hl_games")
      .select("*")
      .eq("slug", slug)
      .single();
    if (error) return null;
    return data;
  }

  async function fetchGameById(id) {
    const { data, error } = await supabase
      .from("hl_games")
      .select("*")
      .eq("id", id)
      .single();
    if (error) return null;
    return data;
  }

  async function fetchPlayerById(id) {
    const { data, error } = await supabase
      .from("hl_players")
      .select("*")
      .eq("id", id)
      .single();
    if (error) return null;
    return data;
  }

  async function pollGameState() {
    if (!currentGame) return;
    const game = await fetchGameById(currentGame.id);
    if (game) {
      currentGame = game;
      await fetchPlayers(game.id);
      scheduleUIUpdate();
    }
  }

  function startPolling() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(pollGameState, 4000);
  }

  function attachRealtime(gameId) {
    supabase
      .channel("hl-game-" + gameId)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "hl_games", filter: `id=eq.${gameId}` },
        payload => {
          if (payload.new) {
            currentGame = payload.new;
            scheduleUIUpdate();
          }
        }
      )
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "hl_players", filter: `game_id=eq.${gameId}` },
        () => {
          fetchPlayers(gameId);
        }
      )
      .subscribe();

    startPolling();
    startTimerLoop();
  }

  function startTimerLoop() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      updateTimerVisuals();
      if (isCreator) checkRoundTimeout();
    }, 200);
  }

  function updateTimerVisuals() {
    if (!currentGame || !currentGame.deadline_at || currentGame.status !== "running") {
      timerValueEl.textContent = "--";
      timerValueEl.classList.remove("timer-critical");
      intermissionOverlay.classList.add("hidden");
      lastSecondShown = null;
      return;
    }

    const timings = getRoundTiming();
    if (!timings) return;
    const now = Date.now();
    const inIntermission = now < timings.guessStartMs;

    if (inIntermission) {
      const countdown = Math.max(0, Math.ceil((timings.guessStartMs - now) / 1000));
      timerValueEl.textContent = countdown.toString();
      timerValueEl.classList.toggle("timer-critical", countdown <= 3);
      intermissionOverlay.classList.remove("hidden");
      intermissionCountEl.textContent = countdown.toString();
      if (countdown !== lastSecondShown && countdown > 0) {
        lastSecondShown = countdown;
        playTickSound(countdown);
      }
      return;
    }

    intermissionOverlay.classList.add("hidden");
    const remaining = Math.max(0, Math.ceil((timings.deadlineMs - now) / 1000));
    timerValueEl.textContent = remaining.toString();
    timerValueEl.classList.toggle("timer-critical", remaining <= 3);

    if (remaining !== lastSecondShown && remaining > 0) {
      lastSecondShown = remaining;
      playTickSound(remaining);
    }
  }

  // --- Game actions ---
  async function createGame() {
    const t = textMap[currentLang];
    const name = document.getElementById("creator-name").value.trim();
    const limit = Number(document.getElementById("time-limit").value);
    const targetScore = Number(document.getElementById("target-score").value);
    const errEl = document.getElementById("create-error");
    errEl.textContent = "";

    if (!name) {
      errEl.textContent = t.errorNameRequired;
      return;
    }

    playClickSound();

    const slug = randomSlug();

    const { data: game, error } = await supabase
      .from("hl_games")
      .insert({
        slug,
        status: "waiting",
        creator_name: name,
        time_limit_seconds: limit,
        target_score: targetScore
      })
      .select()
      .single();

    if (error) {
      errEl.textContent = "Oyun olu≈üturulamadƒ±: " + error.message;
      return;
    }

    const { data: player, error: pErr } = await supabase
      .from("hl_players")
      .insert({
        game_id: game.id,
        name,
        is_creator: true,
        streak: 0,
        has_shield: false
      })
      .select()
      .single();

    if (pErr) {
      errEl.textContent = "Oyuncu eklenemedi: " + pErr.message;
      return;
    }

    isCreator = true;
    currentGame = game;
    currentPlayer = player;
    resetLocalScoreSoundState();

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(t.logGameCreated(game.slug));

    saveLocalState();
    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  async function joinGameByCode() {
    const t = textMap[currentLang];
    const name = document.getElementById("join-name").value.trim();
    const code = document.getElementById("join-code").value.trim().toUpperCase();
    const errEl = document.getElementById("join-error");
    errEl.textContent = "";

    if (!name) {
      errEl.textContent = t.errorNameRequired;
      return;
    }
    if (!code) {
      errEl.textContent = t.errorCodeRequired;
      return;
    }

    const game = await fetchGameBySlug(code);
    if (!game) {
      errEl.textContent = t.errorRoomNotFound;
      return;
    }

    playClickSound();

    const { data: player, error: pErr } = await supabase
      .from("hl_players")
      .insert({
        game_id: game.id,
        name,
        is_creator: false,
        streak: 0,
        has_shield: false
      })
      .select()
      .single();

    if (pErr) {
      errEl.textContent = "Oyuncu eklenemedi: " + pErr.message;
      return;
    }

    isCreator = !!player.is_creator;
    currentGame = game;
    currentPlayer = player;
    resetLocalScoreSoundState();

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(t.logJoined(game.slug));

    saveLocalState();
    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  async function startGame() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];

    const aliveCount = players.length;
    if (aliveCount < 2) {
      log(currentLang === "tr" ? "En az 2 oyuncu olmalƒ±." : "At least 2 players are required.");
      return;
    }

    playClickSound();

    const firstCard = randCard();
    const now = new Date();
    const guessStart = new Date(now.getTime() + INTERMISSION_MS);
    const deadline = new Date(guessStart.getTime() + currentGame.time_limit_seconds * 1000);

    const { data, error } = await supabase
      .from("hl_games")
      .update({
        status: "running",
        started_at: now.toISOString(),
        current_card: firstCard,
        round_number: 1,
        deadline_at: deadline.toISOString()
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (error) {
      log("Oyun ba≈ülatƒ±lamadƒ±: " + error.message);
      return;
    }

    // t√ºm tahminleri sƒ±fƒ±rla
    await supabase.from("hl_players").update({ last_guess: null }).eq("game_id", currentGame.id);

    currentGame = data;
    resetLocalScoreSoundState();
    log(t.logStart(firstCard, currentGame.time_limit_seconds));
    scheduleUIUpdate();
  }

  async function endGame() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];
    playClickSound();
    const now = new Date();
    const { data, error } = await supabase
      .from("hl_games")
      .update({ status: "finished", ended_at: now.toISOString(), deadline_at: null })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (!error && data) {
      currentGame = data;
      log(t.logEndedByHost);
      scheduleUIUpdate();
    }
  }

  async function sendGuess(direction, btnEl) {
    const t = textMap[currentLang];
    if (!currentGame || !currentPlayer) return;
    if (currentGame.status !== "running" || !currentGame.deadline_at) {
      setGuessFeedback(t.guessTooLate, true);
      return;
    }

    const timings = getRoundTiming();
    const now = Date.now();
    if (!timings) return;
    if (now < timings.guessStartMs) {
      setGuessFeedback(t.guessTooEarly, true);
      return;
    }
    if (now > timings.deadlineMs) {
      setGuessFeedback(t.guessTooLate, true);
      return;
    }

    const me = players.find(p => p.id === currentPlayer.id);
    if (me && me.last_guess) {
      setGuessFeedback(t.guessSaved, false);
      return;
    }

    getAudioCtx();

    if (btnEl) {
      btnEl.classList.add("guess-btn-pressed");
      setTimeout(() => btnEl.classList.remove("guess-btn-pressed"), 180);
    }

    const { data, error } = await supabase
      .from("hl_players")
      .update({ last_guess: direction })
      .eq("id", currentPlayer.id)
      .select()
      .single();

    if (error) {
      console.error("Failed to save guess:", error);
      setGuessFeedback(
        currentLang === "tr"
          ? "Tahmin kaydedilemedi."
          : "Guess could not be saved.",
        true
      );
      return;
    }

    if (data) {
      playClickSound();
      setGuessFeedback(t.guessSaved, false);
      currentPlayer = data;
      players = players.map(p => (p.id === data.id ? data : p));
      scheduleUIUpdate();
    }
  }

  function exitRoom() {
    clearLocalState();
    if (pollInterval) clearInterval(pollInterval);
    if (timerInterval) clearInterval(timerInterval);
    resetLocalScoreSoundState();
    window.location.href = window.location.pathname;
  }

  async function checkRoundTimeout() {
    if (!isCreator) return;
    if (!currentGame || currentGame.status !== "running") return;
    if (!currentGame.deadline_at) return;

    const timings = getRoundTiming();
    if (!timings) return;
    const now = Date.now();
    if (now <= timings.deadlineMs + GRACE_MS) return;

    await resolveRound();
  }

  async function resolveRound() {
    if (!isCreator || resolvingRound) return;
    if (!currentGame || !currentGame.current_card) return;
    const baseTimings = getRoundTiming();
    if (!baseTimings) return;
    if (Date.now() <= baseTimings.deadlineMs + GRACE_MS) return;

    resolvingRound = true;
    const t = textMap[currentLang];

    try {
      const freshGame = await fetchGameById(currentGame.id);
      if (!freshGame || freshGame.status !== "running" || !freshGame.deadline_at) {
        if (freshGame) currentGame = freshGame;
        return;
      }

      const timings = (() => {
        const d = new Date(freshGame.deadline_at).getTime();
        return {
          deadlineMs: d,
          guessStartMs: d - freshGame.time_limit_seconds * 1000
        };
      })();

      if (Date.now() <= timings.deadlineMs + GRACE_MS) {
        currentGame = freshGame;
        return;
      }

      const roundNumber = freshGame.round_number || 1;

      // try to lock this round (idempotent)
      const { data: lockedGame, error: lockErr } = await supabase
        .from("hl_games")
        .update({ deadline_at: null })
        .eq("id", freshGame.id)
        .eq("round_number", roundNumber)
        .eq("status", "running")
        .eq("deadline_at", freshGame.deadline_at)
        .select()
        .single();

      if (lockErr || !lockedGame) {
        currentGame = freshGame;
        return;
      }

      currentGame = lockedGame;

      const { data: curPlayers, error } = await supabase
        .from("hl_players")
        .select("*")
        .eq("game_id", currentGame.id);

      if (error || !curPlayers) return;

      const current = freshGame.current_card;
      const next = randCard();

      const updates = curPlayers.map(async p => {
        const guess = p.last_guess;
        const streakBefore = p.streak || 0;
        let streakAfter = streakBefore;
        let hasShield = !!p.has_shield;
        let baseScore = 0;
        let correct = false;

        if (!guess) {
          baseScore = -1; // tahmin yok
        } else if (guess === "same") {
          correct = next === current;
          baseScore = correct ? 5 : -2; // ultra riskli
        } else {
          const guessHigher = guess === "higher";
          const success = (guessHigher && next > current) || (!guessHigher && next < current);
          const safe = isSafeGuess(current, guess);
          correct = success;
          if (success) baseScore = safe ? 1 : 3;
          else baseScore = safe ? 0 : -1;
        }

        if (correct) streakAfter = streakBefore + 1;
        else streakAfter = 0;

        let shieldUsed = false;
        if (!correct && baseScore < 0 && hasShield) {
          baseScore = 0;
          hasShield = false;
          shieldUsed = true;
        }

        const comboMultiplier = getComboMultiplier(streakAfter);
        const finalScore = Math.round(baseScore * comboMultiplier);
        let newShield = hasShield;
        if (streakAfter >= 3 && !newShield) newShield = true;

        const updatePayload = {
          score: (p.score || 0) + finalScore,
          streak: streakAfter,
          has_shield: newShield,
          last_guess: null
        };

        await supabase.from("hl_players").update(updatePayload).eq("id", p.id);

        if (!guess) {
          log(t.logNoGuess(p.name));
          log(t.logScoreDelta(p.name, finalScore));
        } else {
          log(t.logScoreDelta(p.name, finalScore));
        }
        if (shieldUsed)
          log(
            currentLang === "tr"
              ? `${p.name}: üõ° kalkan cezayƒ± sildi.`
              : `${p.name}: üõ° shield absorbed the penalty.`
          );
      });

      await Promise.all(updates);

      playRevealSound();
      log(t.logRoundResult(current, next));

      const { data: updatedPlayers } = await supabase
        .from("hl_players")
        .select("*")
        .eq("game_id", currentGame.id);

      players = updatedPlayers || curPlayers;

      const target = freshGame.target_score || 10;
      const winner = (updatedPlayers || []).find(p => (p.score || 0) >= target);
      const everyoneLow = (updatedPlayers || []).every(
        p => (p.score || 0) <= VERY_LOW_SCORE
      );

      if (winner || everyoneLow) {
        const { data, error: gErr } = await supabase
          .from("hl_games")
          .update({
            status: "finished",
            ended_at: new Date().toISOString(),
            current_card: next,
            deadline_at: null
          })
          .eq("id", currentGame.id)
          .eq("round_number", roundNumber)
          .select()
          .single();

        if (!gErr && data) {
          currentGame = data;
        }
        if (winner) log(t.logWin(winner.name));
        if (!winner && everyoneLow) log(t.logAutoLow);
        return;
      }

      // oyun devam: yeni tur (intermission + s√ºre)
      const now = new Date();
      const guessStart = new Date(now.getTime() + INTERMISSION_MS);
      const deadline = new Date(
        guessStart.getTime() + freshGame.time_limit_seconds * 1000
      );

      const { data: newGame, error: updErr } = await supabase
        .from("hl_games")
        .update({
          current_card: next,
          round_number: roundNumber + 1,
          deadline_at: deadline.toISOString()
        })
        .eq("id", currentGame.id)
        .eq("round_number", roundNumber)
        .select()
        .single();

      if (!updErr && newGame) {
        currentGame = newGame;
      }

      await fetchPlayers(currentGame.id);
    } finally {
      resolvingRound = false;
      scheduleUIUpdate();
    }
  }

  async function resetScoresAndContinue() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];

    playClickSound();

    await supabase
      .from("hl_players")
      .update({ score: 0, last_guess: null, streak: 0, has_shield: false })
      .eq("game_id", currentGame.id);

    const firstCard = randCard();
    const now = new Date();
    const guessStart = new Date(now.getTime() + INTERMISSION_MS);
    const deadline = new Date(guessStart.getTime() + currentGame.time_limit_seconds * 1000);

    const { data, error } = await supabase
      .from("hl_games")
      .update({
        status: "running",
        started_at: now.toISOString(),
        ended_at: null,
        current_card: firstCard,
        round_number: 1,
        deadline_at: deadline.toISOString()
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (error) {
      log("Oyun ba≈ülatƒ±lamadƒ±: " + error.message);
      return;
    }

    currentGame = data;
    resetLocalScoreSoundState();
    log(t.logStart(firstCard, currentGame.time_limit_seconds));
    await fetchPlayers(currentGame.id);
    scheduleUIUpdate();
  }

  async function autoRejoinIfPossible() {
    const params = new URLSearchParams(window.location.search);
    const gameSlugParam = params.get("game");
    if (gameSlugParam) {
      document.getElementById("join-code").value = gameSlugParam.toUpperCase();
    }

    let saved = null;
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (raw) saved = JSON.parse(raw);
    } catch (_) {}

    if (!saved?.gameSlug || !saved?.playerId) return;

    const game = await fetchGameBySlug(saved.gameSlug);
    if (!game) {
      clearLocalState();
      return;
    }

    const player = await fetchPlayerById(saved.playerId);
    if (!player) {
      clearLocalState();
      return;
    }

    currentGame = game;
    currentPlayer = player;
    isCreator = !!player.is_creator;
    resetLocalScoreSoundState();

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(textMap[currentLang].logJoined(game.slug));

    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  // Events
  document.getElementById("create-game-btn").onclick = createGame;
  document.getElementById("join-game-btn").onclick = joinGameByCode;
  guessBtnHigher.onclick = () => sendGuess("higher", guessBtnHigher);
  guessBtnLower.onclick = () => sendGuess("lower", guessBtnLower);
  guessBtnSame.onclick = () => sendGuess("same", guessBtnSame);

  const langButtons = document.querySelectorAll(".lang-btn");
  langButtons.forEach(btn => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) btn.classList.add("active");
    btn.addEventListener("click", () => {
      currentLang = lang;
      localStorage.setItem(LS_LANG, currentLang);
      langButtons.forEach(b =>
        b.classList.toggle("active", b.dataset.lang === currentLang)
      );
      applyLanguage();
    });
  });

  // init
  applyLanguage();
  autoRejoinIfPossible();
</script>
</body>
</html>
